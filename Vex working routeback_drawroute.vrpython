{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n#walls based off the heading value\n# 0b0001 = right wall\n# 0b0010 = front wall\n# 0b0100 = left wall\n# 0b1000 =back wall\n#can be combined (0b1010=front wall+back wall)\nimport heapq\n\n\n\ndef print_maze_matrix(mazeMatrix):\n  \n    brain.new_line()\n    for row in mazeMatrix:\n        row_str = \"\"\n        for cell in row:\n            if cell == 0:\n                row_str += \"0   \"  # unvisited\n            elif cell == 1:\n                row_str += \"1   \"  # visited once\n            elif cell == 2:\n                row_str += \"2   \"  # visited x2(wrong way)\n            elif cell == 3:\n                row_str += \"3   \"  # junction\n            elif cell == 5:\n                row_str += \"5   \"  # out of bounds\n            elif cell == 6:\n                row_str += \"6   \"  #  finish\n            elif cell == 7:\n                row_str += \"7   \"  # start\n            else:\n                row_str += \"?   \"  # invalid value\n        brain.print(row_str.strip())  #better formatting\n        brain.new_line()\n\ndef print_wall_matrix(wallMatrix):\n    #symbols to make reading th egraph easier for debugging\n    symbols = {\n        0b0000: \"    \",  \n        0b0001: \"→   \",  \n        0b0010: \"↑   \",  \n        0b0100: \"←   \",  \n        0b1000: \"↓   \",  \n        0b0011: \"→↑  \",  \n        0b0110: \"←↑  \", \n        0b1100: \"←↓  \",  \n        0b1001: \"→↓  \",  \n        0b0101: \"←→  \", \n        0b1010: \"↓↑  \", \n        0b0111: \"←↑→ \",  \n        0b1110: \"←↓↑ \", \n        0b1101: \"←↓→ \",  \n        0b1011: \"↓↑→ \",  \n        0b1111: \"←↓↑→\"  \n    }\n\n    \n    for row in wallMatrix:\n        row_str = \"| \"  #separator\n        for cell in row:\n            \n            symbol = symbols.get(cell, \"    \") \n            row_str += f\"{symbol}| \"  # format to same width\n        brain.print(row_str)  \n        brain.new_line()\n\n\ndef explore_unvisited_areas(mazeMatrix, wallMatrix, finished):\n  \n\n    while finished==False:\n        unvisited_positions = [(x, y) for y in range(1, 9) for x in range(1, 9) if mazeMatrix[y][x] == 0]\n\n        if not unvisited_positions:\n            \n            return True #unvisited positions all found\n\n        for targetX, targetY in unvisited_positions:\n            \n            \n            \n            # move to unvisited tile/tile group\n            found_Tile = move_to_target(targetX, targetY, wallMatrix, mazeMatrix, unvisited_positions)\n\n            if found_Tile:\n                \n              \n              \n\n                robotX = int(round(((location.position(X, MM) + 1150)) / 250))\n                robotY = int(round(((location.position(Y, MM) - 1150)) / 250)) * -1\n                if drivetrain.heading(DEGREES)==0:\n                    robotY=robotY+1\n                elif drivetrain.heading(DEGREES)==180:\n                    robotY=robotY-1\n                elif drivetrain.heading(DEGREES)==90:\n                    robotX=robotX-1   \n                else:\n                    robotX=robotX+1\n\n              \n\n                \n                start_x, start_y = robotX, robotY\n               \n\n                # left wall follow during unknown unvisited section\n                follow_left_wall_in_section(start_x, start_y, wallMatrix, mazeMatrix)\n\n                if mazeMatrix[targetY][targetX] > 2:\n                    mazeMatrix[robotY][robotX] = 1  # mark visited\n\n            else:\n                #if mazeMatrix[targetY][targetX] > 2:\n                 #   mazeMatrix[targetY][targetX] = 2  # Mark as dead end\n                break #refreshes the function, and acts as a break for when the robot is finished also, causing it to stop\n\n\n\n\n\ndef move_to_target(targetX, targetY, wallMatrix, mazeMatrix, unvisited):\n    routeback=False\n    startX = int(round(((location.position(X, MM) + 1150)) / 250))\n    startY = int(round(((location.position(Y, MM) - 1150)) / 250)) * -1\n    unvisited_Tiles=False\n    #check for unvisited\n    endX, endY = None, None\n    for y in range(len(mazeMatrix)):\n        for x in range(len(mazeMatrix[0])):\n            if mazeMatrix[y][x] == 0:  # cehck for unvisited\n                endX, endY = x, y\n                unvisited_Tiles=True\n                break\n    #check for maze start\n    if mazeMatrix[startY][startX] != 6 and endX is None and endY is None:\n        for y in range(len(mazeMatrix)):\n            for x in range(len(mazeMatrix[0])):\n                if mazeMatrix[y][x] == 6:\n                    routeback=True  # find end\n                    endX, endY = x, y\n                    break            \n    #check for maze end\n    if mazeMatrix[startY][startX] == 6 and endX is None and endY is None:\n        for y in range(len(mazeMatrix)):\n            for x in range(len(mazeMatrix[0])):\n                if mazeMatrix[y][x] == 7:\n                    routeback=True  # find start\n                    endX, endY = x, y\n                    break\n        \n    \n    # pathfinding (Dijkstra's)\n    rows, cols = len(mazeMatrix), len(mazeMatrix[0])\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[startY][startX] = 0\n    priority_queue = [(0, (startX, startY))]\n    prev = {}  # store shortest path\n    \n    directions = [(0, -1, 0b0010), (0, 1, 0b1000), (1, 0, 0b0001), (-1, 0, 0b0100)]  # (dx, dy, wall_bit)\n    \n    while priority_queue:\n        current_distance, (x, y) = heapq.heappop(priority_queue)\n        \n        if (x, y) == (endX, endY):  \n            break\n        \n        for dx, dy, wall_bit in directions:\n            nx, ny = x + dx, y + dy\n            \n            # ensure tiles that are 2 and 5 are ignored, since they will not be needed\n            if 0 <= ny < rows and 0 <= nx < cols and (wallMatrix[y][x] & wall_bit) == 0 and mazeMatrix[ny][nx] not in [2, 5]:\n                new_distance = current_distance + 1\n                if new_distance < distances[ny][nx]:\n                    distances[ny][nx] = new_distance\n                    prev[(nx, ny)] = (x, y)\n                    heapq.heappush(priority_queue, (new_distance, (nx, ny)))\n    \n    \n    path = []\n    cx, cy = endX, endY\n    while (cx, cy) in prev:\n        path.append((cx, cy))\n        cx, cy = prev[(cx, cy)]\n    path.reverse()\n    \n    # path generation\n    brain.print(f\"path: {path}\")\n    \n    # robot movement\n    robotX, robotY = startX, startY\n    for px, py in path:\n        dx = px - robotX\n        dy = py - robotY\n        \n      \n        \n        if dx == 1:\n           \n            drivetrain.turn_to_heading(90, DEGREES)\n        elif dx == -1:\n            \n            drivetrain.turn_to_heading(270, DEGREES)\n        elif dy == 1:\n           \n            drivetrain.turn_to_heading(180, DEGREES)\n        elif dy == -1:\n            \n            drivetrain.turn_to_heading(0, DEGREES)\n        \n        drivetrain.drive_for(FORWARD, 250, MM)\n        robotX, robotY = px, py  # Update manual position tracking\n        if mazeMatrix[py][px] == 0:\n            return True\n        #if mazeMatrix[py][px] == 6 and unvisited_Tiles==False:\n         #   return False\n    if (robotX, robotY) == (endX, endY):\n      brain.print(\"start found\")\n    else:\n        brain.print(\"error\")\n\n\n\n    if (robotX, robotY) == (endX, endY) and routeback==True and mazeMatrix[endY][endX]==7:\n        brain.print(\"Successfully reached the start position.\")\n        drivetrain.stop()\n        \n        brain.print(\"Final matrix mapping\")\n        print_maze_matrix(mazeMatrix)\n        print_wall_matrix(wallMatrix)\n        create_final_matrix(mazeMatrix, path)\n        return False\n    elif (robotX, robotY) == (targetX, targetY):\n        if mazeMatrix[robotY][robotX]==6 and routeback==True:\n            move_to_target(targetX, targetY, wallMatrix, mazeMatrix, unvisited)\n        return True\n    else:\n       \n        return False\n\n\n\n\n\ndef follow_left_wall_in_section(start_x, start_y, wallMatrix, mazeMatrix):\n    # current position\n    robotX = int(round(((location.position(X, MM) + 1150)) / 250))\n    robotY = int(round(((location.position(Y, MM) - 1150)) / 250)) * -1 \n    \n \n    robotHeading = drivetrain.heading(DEGREES)\n    \n    print_wall_matrix(wallMatrix)\n    print_maze_matrix(mazeMatrix)\n    visited_positions = set()  # keep track of visited positions\n\n    while True:\n        \n        \n\n        detect_and_update_maze(wallMatrix, mazeMatrix, robotX, robotY, robotHeading)\n        # check if start has been returned to\n        if (robotX, robotY) == (start_x, start_y) and visited_positions:\n            return\n            \n\n        visited_positions.add((robotX, robotY))\n\n        # left wall following logic\n        front_wall = front_eye.detect(RED)\n        drivetrain.turn_for(LEFT, 90, DEGREES)\n        left_wall = front_eye.detect(RED)\n        drivetrain.turn_for(RIGHT, 180, DEGREES)\n        right_wall = front_eye.detect(RED)\n        drivetrain.turn_for(LEFT, 90, DEGREES)\n\n        \n\n       #left wall follow logic\n        if not left_wall:\n        \n            drivetrain.turn_for(LEFT, 90, DEGREES)\n            drivetrain.drive_for(FORWARD, 250, MM)\n        elif front_wall and left_wall:\n          \n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            drivetrain.drive_for(FORWARD, 250, MM)\n        elif not front_wall:\n            # \n            drivetrain.drive_for(FORWARD, 250, MM)\n        else:\n          \n        \n            drivetrain.turn_for(RIGHT, 180, DEGREES) \n            drivetrain.drive_for(FORWARD, 250, MM)  \n\n\n        # update position\n        robotX = int(round(((location.position(X, MM) + 1150)) / 250))\n        robotY = int(round(((location.position(Y, MM) - 1150)) / 250)) * -1\n\n       \n        wait(5, MSEC)\n\n\n\n\n\n\n\n\n\n\ndef detect_and_update_maze(wallMatrix, mazeMatrix, x, y, heading):\n    \n    # bit based wall values\n    WALL_FRONT = 0b0010\n    WALL_LEFT = 0b0100\n    WALL_RIGHT = 0b0001\n    WALL_BACK = 0b1000 \n\n    # heading based for wall coordinites\n    direction_offsets = {\n        0: {'front': (x, y-1), 'left': (x-1, y), 'right': (x+1, y), 'back': (x, y+1)},  # North\n        90: {'front': (x+1, y), 'left': (x, y+1), 'right': (x, y-1), 'back': (x-1, y)},  # East\n        180: {'front': (x, y+1), 'left': (x+1, y), 'right': (x-1, y), 'back': (x, y-1)},  # South\n        270: {'front': (x-1, y), 'left': (x, y-1), 'right': (x, y+1), 'back': (x+1, y)}   # West\n    }\n\n    available_directions = 0  # set as 0, to reset\n\n    def update_wall(direction, wall_bit):\n       \n        nonlocal available_directions\n        nx, ny = direction_offsets[heading][direction]\n\n        # make sure that its in bounds of the maze\n        if 0 <= nx < len(wallMatrix[0]) and 0 <= ny < len(wallMatrix):\n            if front_eye.detect(RED):  # wall found\n                wallMatrix[y][x] |= wall_bit  # append matrix bit to have a wall added\n            else:\n                available_directions += 1  #no wall found, +1 path\n\n  \n \n\n    robotHeading = drivetrain.heading(DEGREES)\n    #updating walls setup with headings\n    drivetrain.turn_to_heading(0, DEGREES)  \n    update_wall('front', WALL_FRONT)\n\n    drivetrain.turn_to_heading(90, DEGREES)  \n    update_wall('right', WALL_RIGHT)\n\n    drivetrain.turn_to_heading(180, DEGREES)  \n    update_wall('back', WALL_BACK)\n\n    drivetrain.turn_to_heading(270, DEGREES)  \n    update_wall('left', WALL_LEFT)\n\n    drivetrain.turn_to_heading(robotHeading, DEGREES)\n\n    #maze matrix updating\n    if mazeMatrix[y][x] != 7 and mazeMatrix[y][x] != 6:  #start pos/end pos shouldnt be overwtitten for backtracking/exploration later\n        if available_directions >= 3:\n            mazeMatrix[y][x] = 3  #junction\n        \n        elif available_directions == 2:\n            if mazeMatrix[y][x] == 1: #previously visited, update as wrong path\n                mazeMatrix[y][x] = 2\n            else:    \n                mazeMatrix[y][x] = 1  # \n        elif available_directions == 0:\n            mazeMatrix[y][x] = 2 #dead end\n        elif available_directions == 1:\n            mazeMatrix[y][x] = 2 # dead end\n    \n    # if dead end turn around\n    if available_directions <= 1:\n        drivetrain.turn_for(RIGHT, 180, DEGREES)\n\n    \n\n    \n    return wallMatrix, mazeMatrix\n\n\n\ndef create_final_matrix(maze, mirrorPath):\n    path=mirrorPath[::-1] #flips path array, since its currently finish to start\n    height, width = len(maze), len(maze[0])\n    final_matrix = [['X' for _ in range(width)] for _ in range(height)]\n    \n    direction_map = {\n        (1, 0): '→',  #directions\n        (-1, 0): '←',\n        (0, 1): '↓',\n        (0, -1): '↑'\n    }\n    \n    start = None\n    finish = None\n    \n    for y in range(height):  #check for start+finish valuse in list ans store\n        for x in range(width):  \n            if maze[y][x] == 7:\n                start = (x, y)  \n            elif maze[y][x] == 6:\n                finish = (x, y)  \n\n    if not start or not finish:\n        \n        return None\n\n    sx, sy = start  \n    fx, fy = finish  \n    \n    if len(path) > 1:\n        first_move = path[1]\n        \n        dx, dy = first_move[0] - sx, first_move[1] - sy  #work out the directions then place arrow\n        final_matrix[sy][sx] = direction_map.get((dx, dy), 'S') \n    else:\n        final_matrix[sy][sx] = 'S'\n\n    for i in range(len(path) - 1):\n        x, y = path[i]  \n        next_x, next_y = path[i + 1]\n        dx, dy = next_x - x, next_y - y  #work out directions\n        final_matrix[y][x] = direction_map.get((dx, dy), 'X')\n          \n            \n    x, y = path[len(path)-1]  \n    next_x, next_y = 4, 1\n    dx, dy = next_x - x, next_y - y  #work out directions\n    final_matrix[y][x] = direction_map.get((dx, dy), 'X')\n            \n\n    final_matrix[fy][fx] = 'F'\n    \n    print_final_matrix(final_matrix)\n\ndef print_final_matrix(matrix):\n    brain.print(\"Final Path:\")\n    brain.new_line()\n    #iterate through final array, then print it out evenly spaced to show the path through the maze\n    for row in matrix:\n        row_str = \"| \"\n        for cell in row:\n            if cell == 'S':\n                row_str += 'S '  #if cell is start\n            elif cell == 'F':\n                row_str += 'F '  #if cell is finish\n            elif cell == '→' or cell == '←' or cell == '↓' or cell == '↑':\n                row_str += cell + \" \"\n            else:\n                row_str += cell + \" \"\n        row_str += \"|\"\n        brain.print(row_str)\n        brain.new_line()\n    brain.new_line()  \n\n\n    \n\n\ndef follow_left_wall(wallMatrix, mazeMatrix):\n    \n    \n   \n    #get probt position\n    robotPositionY = int(round(((location.position(Y, MM) - 1150)) / 250)) * -1\n    robotPositionX = int(round(((location.position(X, MM) + 1150)) / 250))\n    robotHeading = drivetrain.heading(DEGREES)\n\n    detect_and_update_maze(wallMatrix, mazeMatrix, robotPositionX, robotPositionY, robotHeading)\n\n    #check for walls\n    front_wall = front_eye.detect(RED)\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    left_wall = front_eye.detect(RED)\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    right_wall = front_eye.detect(RED)\n    \n   \n\n    #left turning, if left is an option it will be followed\n    if not left_wall: \n        drivetrain.turn_for(LEFT, 90, DEGREES)\n        drivetrain.drive_for(FORWARD, 250, MM)\n    elif front_wall and left_wall:  \n        drivetrain.turn_for(RIGHT, 90, DEGREES)\n        drivetrain.drive_for(FORWARD, 250, MM)\n    elif not front_wall:  \n        drivetrain.drive_for(FORWARD, 250, MM)\n\ndef main():\n    pen.set_pen_color_rgb(255,165,0,1)\n    \n    pen.move(DOWN)\n    # matrix declaration, maze is 8x8, but 10x10 is used for checking,\n    # since sometimes it would try to check squares outside the array,\n    # so this fixes the issue\n    mazeMatrix = [[0 for x in range(10)] for x in range(10)]\n    wallMatrix = [[0b0000 for x in range(10)] for x in range(10)]\n\n    # set borders to 5, so robot knows where the edge of the maze is\n    for x in range(10):\n        mazeMatrix[0][x] = 5\n        mazeMatrix[9][x] = 5\n    for y in range(10):\n        mazeMatrix[y][0] = 5\n        mazeMatrix[y][9] = 5\n    finished=False \n    \n    robotPositionY = int(round(((location.position(Y, MM) - 1150)) / 250)) * -1\n    robotPositionX = int(round(((location.position(X, MM) + 1150)) / 250))\n    \n    # mark start\n    if 0 <= robotPositionX < 10 and 0 <= robotPositionY < 10:\n        mazeMatrix[robotPositionY][robotPositionX] = 7  # mark start of maze\n\n    drivetrain.set_drive_velocity(200, PERCENT)\n    drivetrain.set_turn_velocity(200, PERCENT)\n\n\n    while finished==False:\n        # \n        #check for finish (red on the ground)\n        if down_eye.detect(RED):\n            brain.new_line()\n            \n            #update matricies\n            robotPositionY = int(round(((location.position(Y, MM) - 1150)) / 250)) * -1\n            robotPositionX = int(round(((location.position(X, MM) + 1150)) / 250))\n            mazeMatrix[robotPositionY][robotPositionX] = 6\n            robotHeading = drivetrain.heading(DEGREES)\n            detect_and_update_maze(wallMatrix, mazeMatrix, robotPositionX, robotPositionY, robotHeading)\n            \n       \n            print_maze_matrix(mazeMatrix)\n            print_wall_matrix(wallMatrix)\n            brain.print(\"explore unvisited \")\n            finished = explore_unvisited_areas(mazeMatrix, wallMatrix, finished)\n            brain.print(\"FINISHED explore unvisited\")\n         \n            \n            \n            \n            while True:    \n                if mazeMatrix[int(round(((location.position(Y, MM) - 1150)) / 250)) * -1][int(round(((location.position(X, MM) + 1150)) / 250))]==7:\n                    break\n                else:\n                    #calls move to target one more time, since in 1 specific case where if the robot visits all squares before reaching end for first time,\n                    #it wont trigger correctly, so this allows the function to be ran and route it back to start\n                    unvisited=[]  \n                    pen.set_pen_color(BLUE)\n                    \n                    move_to_target(0, 0, wallMatrix, mazeMatrix, unvisited)\n            finished=True\n            break     \n            \n\n        else:\n           \n            \n                \n            follow_left_wall(wallMatrix, mazeMatrix)\n            \n        \n        wait(5, MSEC)\n\n\n\n\n# VR threads — Do not delete\nvr_thread(main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}